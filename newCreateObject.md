### 一、工厂模式  
解决了创建多个相似对象的问题，没有解决对象识别的问题，即怎样识别对象的类型。

### 二、构造函数模式  
使用new操作符调用构造函数经历的4个步骤:
```
1.创建一个对象  
2.将构造函数的作用域赋给新对象(this指向新对象)
3.执行构造函数中的代码(为这个新对象添加属性)
4.返回新对象
```
对象的`constructor`属性最初是标识对象类型  
检测对象类型，还是`instanceof`  
构造函数模式胜过工厂模式在于*将它的实例标识为一种特定的类型*
不同实例的`同名函数是不相等`的，构造函数中的方法是通过new Function得来的。    
优化：可以在函数外部设置全局函数供对象共享  
问题：如果对象需要定义多个方法，需要定义多个全局对象。

### 三、原型模式
每个函数都有`prototype`属性,这是一个指针，指向一个包含由特定类型的所有实例共享的属性和方法的对象，这个对象自动获得`constructor`属性，指向构造函数。  

不必在构造函数中定义对象实例的信息，可以把他们添加到原型对象中。

与构造函数不同的是，`原型对象`的这些属性和方法是所有实例共享的，(同一组属性，同样的方法)  

`构造函数`的prototype指向原型对象，原型对象的constructor属性又指回构造函数。  
`原型对象`除了constructor属性，包括添加的其他属性。  
构造函数的每个`实例`都包含一个内部属性`[[Prototype]] (__proto__)`,该属性指向原型对象，与构造函数没有直接关系。  
判断实例中是否有[[Prototype]],通过原型对象的`isPrototypeOf()`方法  

获取对象的原型通过`Object.getPrototypeOf()`  
判断该属性是不是实例中的通过`hasOwnProperty()`  
判断该属性是不是原型中的通过
```
function hasPrototypeProperty(object,name){
  return !object.hasOwnProperty(name) && (name in object);
}
```
获取所有可枚举属性通过`Object.keys()`  
获取所有属性通过`Object.getOwnPropertyNames()`  
*constructor属于不可枚举属性*

#### 原型模式的缺点
* 省略了为构造函数传递初始化参数，实例在默认情况下取得相同的属性值
* 因为原型的所有属性被很多实例共享，对于包含基本值的属性没有影响，对于包含引用类型的值的属性来说，修改某个实例的属性，所有的实例均共享此修改的属性。  

### 四、组合使用构造函数模式和原型模式
1. 构造函数模式用于定义实例属性
2. 原型模式用于定义方法和共享属性

这样每个实例既有一份独自的实例属性的副本，又共享着对方法的引用。  

### 五、动态原型模式
```
function Person(name,age,job){
  this.name=name;
  this.age=age;
  this.job=job;

  if(typeof this.sayName!='function'){
    Person.prototype.sayName=function(){
      alert(this.name);
    }
  }
}
```
不能使用对象字面量重写原型，会切断现有实例与新原型之间的联系。
### 六、寄生构造函数模式
返回的对象跟构造函数或者构造函数的原型属性之间没有关系，不能依赖instanceof操作符来确定对象类型。

### 七、稳妥构造函数模式
只能使用函数获取私有属性，而不能通过this。
